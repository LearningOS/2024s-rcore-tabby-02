# 一.实现功能

实现了在引入虚拟内存机制后的系统调用函数sys_gettime,sys_taskinfo,sys_mmap,sys_mumap。和ch3一样的是在TCB中加入TaskInfo和begintime两项，用于记录任务执行信息info和任务开始时间，区别为在写入数据时都通过tanslate函数将内核虚拟地址映射找到用户空间的物理地址，完成数据的传入。然后sys_mmap调用insert_framed_areas函数申请空间，并完成了错误判别和处理，sys_mumap同理，调用了umap回收空间，还要去除mapareas里的vec对应项。

# 二.简答作业

1.一共64位，53-10的44位是物理页号，7-0的8位是标志位，含义如下
V:仅当 V(Valid) 位为 1 时，页表项才是合法的；
R/W/X: 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；
U: 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；
A:记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
D:则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。
2.(1).缺页异常（Page Fault Exception）是由于进程访问的页面不在页表中或者在页表中无效而引发的异常。
(2).发生缺页时相关重要寄存器的值：
  PC：指向导致缺页异常的指令的地址。
  sat：保存当前进程的页表基址。
(3). Lazy 策略的好处：
   - 减少了启动时的内存开销：延迟了内存页面的加载，避免了不必要的磁盘IO和内存占用。
   - 提高了程序启动速度：避免了一开始就加载大量不被立即使用的内存页面，减少了启动时间。
(4).  10G 连续的内存页面×5121​=20M 个二级页表。每个二级页表占用 4KB 的内存，因此所有二级页表占用的内存量为：20M 个二级页表×4KB/表=80GB20M 个二级页表×4KB/表=80GB。
(5). 实现 Lazy 策略和缺页处理：
   - 实现 Lazy 策略可以在页表中将页面标记为“未加载”状态，在进程访问页面时检查该标记。如果页面未加载，则触发缺页异常。
   - 处理缺页时，操作系统可以根据页面的状态进行不同的处理：如果页面未加载，则从磁盘加载页面到内存；如果页面已加载但被换出到磁盘，则将页面换入内存并更新页表；如果页面是无效的，则终止进程或者给出错误提示。
(6). 页面失效在页表项上的表现：
   - 当页面失效时，页表项的有效位V通常会被清零，表示页面当前不在内存中。此外，其他相关标志位（如脏位D、访问位A等）可能也会被修改以反映页面的状态。
3.
(1).  在单页表情况下，更换页表通常涉及修改控制寄存器中存储的页表基址。当操作系统需要切换到另一个进程的地址空间时，它会将当前进程的页表基址替换为新进程的页表基址，从而实现页表的更换。
(2). 在切换到用户态时，使所有内核页面失效，这样用户态就无法访问内核页面了。
(3).  单页表的优势在于实现简单、效率高。由于所有进程共享同一张页表，不需要在进程切换时进行页表切换操作，从而减少了上下文切换的开销和操作系统的复杂性。
(4).  在双页表实现下，通常需要在发生进程切换时更换页表。当操作系统将控制权从一个进程切换到另一个进程时，需要加载新进程的页表，以确保新进程能够访问正确的地址空间。如果是单页表操作系统，页表的更换时机也会是在进程切换时，但是更换的对象是同一张页表的内容，而不是加载不同的页表。
# 三.荣誉准则

1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 

2.此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> [rCore-Tutorial-Guide-2024S 文档](https://learningos.cn/rCore-Tutorial-Guide-2024S/)

3.我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4.我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。