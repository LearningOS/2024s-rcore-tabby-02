# 一.实现功能

记录了task的各项信息，包括任务执行状态，系统调用次数，任务执行时长，并实现了sys_task_info函数取出这些信息。

具体实现方式是：首先修改了TCB的内容，新增加TaskInfo和begintime两项，用于记录任务执行信息info和任务开始时间；在syscall函数的进入具体系统调用函数之前对syscall_times进行更改；在run_next_task函数中对begintime进行记录和更改；之后在sys_task_info的实现过程中取得并返回task的信息。所有对TCB中的TaskInfo等信息的访问是通过TASK_MANAGER进行的。

# 二.简答作业

1.

rustsbi 0.2.0-alpha.1 已经修复，可以正常退出

sbi版本--------------RustSBI version 0.3.0-alpha.2

2.



(1).寄存器 a0 指向内核栈的栈指针。从栈上的 Trap 上下文恢复的时候，即`trap_handler` 返回之后。

(2).这是将内核栈分别加载到三个寄存器t0,t1,t2上，再写入到CSR(sstatus,sepc,sscratch)

意义是从内核栈顶的 Trap 上下文恢复 CSR。具体为sstatus的`SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息，sepc为当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址，sscratch 目前保存用户栈栈顶，在之后会与保存了内核栈的sp交换内容。

(3).不保存 sp(x2)，因为它在第 13 行 后指向的是内核栈。用户栈的栈指针保存在 sscratch 中，必须通过 `csrr` 指令读到通用寄存器中后才能使用，因此我们先考虑保存其它通用寄存器，腾出空间。

不保存tp(x4) 寄存器，应用一般都用不到，除非我们手动出于一些特殊用途使用它。

(4).这里起到的是交换 sscratch 和 sp 的效果。在这一行之前 sp 指向内核栈， sscratch 指向用户栈（因为13行而发生了互换），现在 sp 指向用户栈， sscratch 指向内核栈。

(5).csrrw sp, sscratch, sp，因为sscratch保存了用户栈顶指针，执行后交换了sp和sscratch的内容，即sp为指向用户栈的指针，即切换到用户栈

(6).这里起到的是交换 sscratch 和 sp 的效果。在这一行之前 sp 指向用户栈， sscratch 指向内核栈，现在 sp 指向内核栈， sscratch 指向用户栈。

(7).csrrw sp, sscratch, sp

# 三.荣誉准则

1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 

2.此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> [rCore-Tutorial-Guide-2024S 文档](https://learningos.cn/rCore-Tutorial-Guide-2024S/)

3.我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4.我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。