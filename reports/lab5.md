# 一.实现功能
实现了sys_enable_deadlock_detect()函数,增加了PCB的新字段mutex_available/need/allocation,sem_available/need/allocation,用于记录资源的剩余可使用量，还需要的量，已分配的量，还有字段deadlock_detect,用于记录是否开启死锁检测。实现了mutex_deadlock_detect()和sem_deadlock_detect()检测函数，检测此时是否会进入死锁状态，是则返回true，修改了sys_semaphore_up，sys_semaphore_down等函数，增加了检测到分配后不会死锁才会允许分配资源的实现过程。
# 二.简答作业
1.内存资源：
    线程栈：每个线程都有自己的栈，需要回收这些栈所占用的内存。
    堆内存：线程可能分配了动态内存，需要确保所有分配的内存都被释放。
锁和同步原语：
    线程可能持有锁或其他同步原语，需要确保这些资源被正确释放。

其他线程的 TaskControlBlock 可能被引用的位置
    调度队列：需要回收。
    同步原语：需要回收。
            
2.区别
    锁状态更新的位置：
        Mutex1：在检查等待队列之前直接将 locked 标志设置为 false。
        Mutex2：仅在等待队列为空时才将 locked 标志设置为 false，如果有任务在等待，它们会被唤醒而不更新 locked 标志。

可能导致的问题

Mutex1 的问题：
当 locked 标志在检查等待队列之前被设置为 false 时，可能会导致在任务切换过程中出现线程 A 执行到 locked = false，但还没来得及检查等待队列，此时线程 B 可能会认为互斥锁已经空闲并获取锁，导致不一致的状态。

# 三.荣誉准则

1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 

2.此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> [rCore-Tutorial-Guide-2024S 文档](https://learningos.cn/rCore-Tutorial-Guide-2024S/)

3.我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4.我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。